// Zeru Standard Library - Linux x86_64 System Calls
// This module provides low-level syscall wrappers using inline assembly.
// It also provides I/O operations as importing is not yet supported
//
// x86_64 Linux syscall convention:
// - rax: syscall number
// - rdi, rsi, rdx, r10, r8, r9: arguments 1-6
// - rax: return value
// - rcx, r11: clobbered by syscall
//
// print(), println(), eprint(), eprintln() are compiler built-ins
// that use implicit OutStream buffers (4KB each for stdout/stderr).
// println/eprintln automatically flush after writing.


const SYS_READ: i64 = 0;
const SYS_WRITE: i64 = 1;
const SYS_MMAP: i64 = 9;
const SYS_MREMAP: i64 = 25;
const SYS_EXIT: i64 = 60;

// mmap flags
const PROT_READ: i64 = 1;
const PROT_WRITE: i64 = 2;
const MAP_PRIVATE: i64 = 2;
const MAP_ANONYMOUS: i64 = 32;

// mremap flags
const MREMAP_MAYMOVE: i64 = 1;

const STDIN: i32 = 0;
const STDOUT: i32 = 1;
const STDERR: i32 = 2;

fn syscall1(nr: i64, arg1: i64) i64 {
    var result: i64 = 0;
    asm volatile (
        "syscall"
        : "={rax}" (result)
        : "{rax}" (nr), "{rdi}" (arg1)
        : "rcx", "r11", "memory"
    );
    return result;
}

fn syscall2(nr: i64, arg1: i64, arg2: i64) i64 {
    var result: i64 = 0;
    asm volatile (
        "syscall"
        : "={rax}" (result)
        : "{rax}" (nr), "{rdi}" (arg1), "{rsi}" (arg2)
        : "rcx", "r11", "memory"
    );
    return result;
}

fn syscall3(nr: i64, arg1: i64, arg2: i64, arg3: i64) i64 {
    var result: i64 = 0;
    asm volatile (
        "syscall"
        :   "={rax}" (result)
        :   "{rax}" (nr),
            "{rdi}" (arg1),
            "{rsi}" (arg2),
            "{rdx}" (arg3)
        : "rcx", "r11", "memory"
    );
    return result;
}

fn syscall5(nr: i64, arg1: i64, arg2: i64, arg3: i64, arg4: i64, arg5: i64) i64 {
    var result: i64 = 0;
    asm volatile (
        "syscall"
        :   "={rax}" (result)
        :   "{rax}" (nr),
            "{rdi}" (arg1),
            "{rsi}" (arg2),
            "{rdx}" (arg3),
            "{r10}" (arg4),
            "{r8}" (arg5)
        : "rcx", "r11", "memory"
    );
    return result;
}

fn syscall6(nr: i64, arg1: i64, arg2: i64, arg3: i64, arg4: i64, arg5: i64, arg6: i64) i64 {
    var result: i64 = 0;
    asm volatile (
        "syscall"
        :   "={rax}" (result)
        :   "{rax}" (nr),
            "{rdi}" (arg1),
            "{rsi}" (arg2),
            "{rdx}" (arg3),
            "{r10}" (arg4),
            "{r8}" (arg5),
            "{r9}" (arg6)
        : "rcx", "r11", "memory"
    );
    return result;
}

struct OutStream {
    fd: i32,
    buffer: Array<u8, 4096>,
    index: usize,

    fn flush(var self) i64 {
        if self.index == 0 {
            return 0;
        }

        var buf_ptr: *u8 = &self.buffer[0];
        var amount_written: i64 = syscall3(SYS_WRITE, self.fd as i64, buf_ptr as i64, self.index as i64);
        self.index = 0;

        if amount_written < 0 {
            return -1;
        }
        return amount_written;
    }

    fn write_bytes(var self, bytes: *u8, count: usize) i64 {
        var src_index: usize = 0;
        var remaining: usize = count;

        while remaining > 0 {
            var space_left: usize = 4096 - self.index;
            var to_copy: usize = remaining;

            if space_left < remaining {
                to_copy = space_left;
            }

            var copy_idx: usize = 0;
            while copy_idx < to_copy {
                var src_ptr: *u8 = bytes + src_index + copy_idx;
                self.buffer[self.index + copy_idx] = *src_ptr;
                copy_idx += 1;
            }

            self.index += to_copy;
            src_index += to_copy;
            remaining -= to_copy;

            if self.index == 4096 {
                var flush_result: i64 = self.flush();
                if flush_result < 0 {
                    return flush_result;
                }
            }
        }

        return count as i64;
    }

    fn write_str(var self, s: *u8) i64 {
        return self.write_bytes(s, strlen(s));
    }
}

fn strlen(s: *u8) usize {
    var len: usize = 0;
    var ptr: *u8 = s;
    while *ptr != 0 {
        len += 1;
        ptr = ptr + 1;
    }
    return len;
}

fn memcpy_ptr(dest: *u8, src: *u8, n: usize) {
    var i: usize = 0;
    while i < n {
        var dest_ptr: *u8 = dest + i;
        var src_ptr: *u8 = src + i;
        *dest_ptr = *src_ptr;
        i += 1;
    }
}

fn read_direct(fd: i32, buf: *u8, count: usize) i64 {
    return syscall3(SYS_READ, fd as i64, buf as i64, count as i64);
}

// =============================================================================
// Memory Allocation Functions
// These functions are called by the compiler for Vec<T> operations.
// =============================================================================

// Allocate `size` bytes of memory using mmap.
// Returns a pointer to the allocated memory, or null (0) on failure.
fn __zeru_alloc(size: usize) *u8 {
    // mmap(addr=NULL, length=size, prot=READ|WRITE, flags=PRIVATE|ANONYMOUS, fd=-1, offset=0)
    var prot: i64 = PROT_READ + PROT_WRITE;
    var flags: i64 = MAP_PRIVATE + MAP_ANONYMOUS;
    var result: i64 = syscall6(SYS_MMAP, 0, size as i64, prot, flags, -1, 0);

    // mmap returns -errno on failure (negative value)
    if result < 0 {
        return 0 as *u8;
    }
    return result as *u8;
}

// Reallocate memory: allocate new_size, copy old data, free old memory.
// Returns pointer to new memory, or null on failure.
fn __zeru_realloc(old_ptr: *u8, old_size: usize, new_size: usize) *u8 {
    if new_size == 0 {
        syscall2(SYS_MUNMAP, old_ptr as i64, old_size as i64);
        return 0 as *u8;
    }
    // Reallocate memory
    var new_ptr: *u8 = syscall5(
        SYS_MREMAP,
        old_ptr,
        old_size,
        new_size,
        MREMAP_MAYMOVE,
        0
    );

    // Check for failure
    if new_ptr as i64 < 0 {
        return 0 as *u8;
    }

    return new_ptr;
}

// Copy n bytes from src to dest.
fn __zeru_memcpy(dest: *u8, src: *u8, n: usize) {
    var i: usize = 0;
    while i < n {
        var dest_ptr: *u8 = dest + i;
        var src_ptr: *u8 = src + i;
        *dest_ptr = *src_ptr;
        i += 1;
    }
}

